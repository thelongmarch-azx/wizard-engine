// Copyright 2024 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def monitor_ = MonitorRegistry.add(
    "cache-sim", "Simulates a cache for a simple memory model.",
    CacheSimulationMonitor.new());


class CacheSimulationMonitor extends Monitor {
    def cache = CacheInstance.new(4, 7, 11, 14);
    def block_size_bits: u7 = 7;
    def bi = BytecodeIterator.new();
    var cache_stats: Array<HashMap<int, CacheStat>>;
    var mod: Module;

    def onParse(module: Module, err: ErrorGen) {
        mod = module;
        cache_stats = Array<HashMap<int, CacheStat>>.new(module.functions.length);
        CacheSimBytecodeInstrumenter.new(beforeMemAccess, module).run();
    }

    def onFinish(i: Instance, r: Result) {
        // disabled printing for performance analysis
        //for (i < cache_stats.length) {
        //    if (cache_stats[i] != null) {
        //        var decl = mod.functions[i];
        //        output_func_header(mod, decl);
        //        var unordered_stats = Vector<(int, CacheStat)>.new();
        //        cache_stats[i].apply(processStats(_, _, unordered_stats));
        //        var len = unordered_stats.length;
        //        var ordered_stats = Arrays.sort(unordered_stats.extract(), 0, len, orderStats);
        //        for (stat in ordered_stats) {
        //            var pc = stat.0;
        //            var name = bi.reset(decl).at(pc).current().mnemonic;
        //            output_cache_stat(stat.0, name, stat.1);
        //        }
        //    }
        //}
	}

    private def processStats(pc: int, stats: CacheStat, accum: Vector<(int, CacheStat)>) {
        accum.put((pc, stats));
    }
    private def orderStats(a: (int, CacheStat), b: (int, CacheStat)) -> bool {
        return a.0 < b.0;
    }

    private def beforeMemAccess(pc: int, func_id: int, address: u64, size: u64) {
        if (cache_stats[func_id] == null) {
            cache_stats[func_id] = HashMap<int, CacheStat>.new(int.!<int>, int.==);
        }
        var old_stats = cache_stats[func_id][pc];
        var hits = old_stats.hits;
        var misses = old_stats.misses;
        var addr_start_index = address >> block_size_bits;
        var addr_end_index = (address + size - 1) >> block_size_bits;
        if (LRUResult.Hit.?(cache.access(u32.view(addr_start_index << block_size_bits)))) {
            hits += 1;
        } else {
            misses += 1;
        }
        if (addr_start_index != addr_end_index) {
            if (LRUResult.Hit.?(cache.access(u32.view(addr_end_index << block_size_bits)))) {
                hits += 1;
            } else {
                misses += 1;
            }
        }
        cache_stats[func_id][pc] = CacheStat(hits, misses);
	}
}

private class CacheSimBytecodeInstrumenter extends BytecodeInstrumenter {
    def var callback: (int, int, u64, u64) -> ();

    new(callback: (int, int, u64, u64) -> (), module: Module) super(module) {
        this.callback = callback;
    }

    def visitLoad(op: Opcode, imm: MemArg, size: u8) {
        var bi = this.bi;
        insertProbeHere(CacheReadProbe.new(callback(bi.pc, bi.func.func_index, _, u64.view(size)), imm, size));
    }
    def visitStore(op: Opcode, imm: MemArg, size: u8) {
        var bi = this.bi;
        insertProbeHere(CacheWriteProbe.new(callback(bi.pc, bi.func.func_index, _, u64.view(size)), imm, size));
    }
}

private class CacheWriteProbe extends MemoryWriteProbe {
    def var callback: (u64) -> ();

    new(callback: (u64) -> (), imm: MemArg, size: u8) {
        this.imm = imm;
        this.size = size;
        this.callback = callback;
        this.has_fire_probe = true;
    }

    def fire_probe(addr: u64, val: u64, unused_val: u64) {
        this.callback(addr);
    }
}

private class CacheReadProbe extends MemoryReadProbe {
    def var callback: (u64) -> ();

    new(callback: (u64) -> (), imm: MemArg, size: u8) {
        this.imm = imm;
        this.size = size;
        this.callback = callback;
    }

    def fire_probe(addr: u64, val: u64, unused_val: u64) {
        this.callback(addr);
    }
}

/***** OUTPUT FORMATTING HELPER METHODS (Do not modify) *****/
/*
 * ***Output Format for Grading:***
 *
 * 1. **Function Header Output:**
 *    - Use the helper method `output_func_header()` to print each function's header.
 *    - The **function headers must be printed in increasing order of function index** 
 *      (e.g., Func[0], Func[1], Func[2], ...).
 *    - **Ensure** that the function header is printed **before** the corresponding cache statistics.
 *
 * 2. **CacheStat Output:**
 *    - After printing each function header, use the helper method `output_cache_stat()` 
 *      to print the cache statistics.
 *    - The **cache statistics must be printed in increasing order of the program counter (pc)** 
 *      for each function.
 *
 * ***Important Notes:***
 * - The **correct order of output** is essential for grading. 
 * - Output **must follow** the specified structure of increasing function index and program counter.
 * - Do not report unvisited functions or accesses>
 * - Do not invoke any output functions other than the methods specified above 
 * - **Double-check your output** to ensure it matches the expected format, as incorrect output will result in lost points.
 */

type CacheStat(hits: u64, misses: u64);

// Method to output function name
def output_func_header(module: Module, func: FuncDecl) {
    Trace.OUT.beginColor(Color.FUNC)
        .put1("func %q:", func.render(module.names, _))
        .endColors().ln();

}
// Method to output a single CacheStat
def output_cache_stat(pc: int, op_mnemonic: string, stat: CacheStat) {
    Trace.OUT.beginColor(Color.INACTIVE)
        .mark()
        .put1("+%d", pc)
        .rjustify_mark(5)
        .endColors()
        .putc(' ');

    Trace.OUT.beginColor(Color.SOURCE)
        .mark()
        .puts(op_mnemonic)
        .rjustify_mark(16)
        .putc(':')
        .putc(' ')
        .endColors();


    Trace.OUT.beginColor(Color.SUCCESS)
        .mark()
        .put1("%d", stat.hits)
        .rjustify_mark(6)
        .endColors()
        .putc(' ');
    Trace.OUT.beginColor(Color.HIGH)
        .mark()
        .put1("%d", stat.misses)
        .rjustify_mark(6)
        .endColors()
        .putc(' ')
        .ln();
}
/******************/


type TagElement(valid: bool, tag: u14, age: u64);

type LRUResult {
    case Hit(t: u14);
    case Miss(t: u14, is_evict: bool, evict: u14);
}


class TagStoreEntry(assoc: int) {
    def elems = Array<TagElement>.new(assoc);

    def is_elem_valid(t: TagElement) -> bool {
        return t.valid;
    }

    def access_update(tag: u14) ->  LRUResult {
        var invalid_idx = -1;
        var hit_idx = -1;
        var rep_idx = -1;
        var is_hit = false;
        var has_invalid = false;
        var max_age: u64 = 0;

        for (i < assoc) {
            if (elems[i].valid) {
                if (elems[i].tag == tag) {
                    // Check for Hit; reset age
                    is_hit = true;
                    hit_idx = i;
                }
                else {
                    if (!has_invalid && (elems[i].age >= max_age)) {
                        // Track oldest element for eviction as long as
                        // there is no invalid element to replace
                        max_age = elems[i].age;
                        rep_idx = i;
                    }
                }
                // Increment age of all valid elements
                elems[i] = TagElement(elems[i].valid, elems[i].tag, elems[i].age + 1);
            } else {
                // There exists an invalid element to fill for miss
                has_invalid = true;
                invalid_idx = i;
            }
        }

        if (is_hit) {
            elems[hit_idx] = TagElement(true, tag, 0);
            return LRUResult.Hit(tag);
        } 
        
        if (has_invalid) {
            elems[invalid_idx] = TagElement(true, tag, 0);
            return LRUResult.Miss(tag, false, 0);
        }

        // All elements are valid and no hit; evict with LRU
        var evict_tag = elems[rep_idx].tag;
        elems[rep_idx] = TagElement(true, tag, 0);
        return LRUResult.Miss(tag, true, evict_tag);
    }
}

class CacheInstance {
    var tag_store: Array<TagStoreEntry>;

    var assoc: int;
    var tag_bits: byte;
    var block_bits: byte;
    var index_bits: byte;

    var block_size: int;
    var index_size: int;

    new (assoc: int, block_bits: byte, index_bits: byte, tag_bits: byte) {
        this.tag_bits = tag_bits;
        this.block_bits = block_bits;
        this.index_bits = index_bits;

        if ((tag_bits + index_bits + block_bits) != 32) {
            System.puts("Cache parameters do not add up to 32 bits.\n");
        }

        this.assoc = assoc;
        this.index_size = (1 << index_bits);
        this.block_size = (1 << block_bits);

        tag_store = Array<TagStoreEntry>.new(this.index_size);
        for (i < this.index_size) {
            tag_store[i] = TagStoreEntry.new(assoc);
        }
    }

    def access(addr: u32) -> LRUResult {
        var offset = u7.!(addr & ((1u << this.block_bits) - 1));
        addr >>= this.block_bits;
        var index = u11.!(addr & ((1u << this.index_bits) - 1));
        addr >>= this.index_bits;
        var tag_val = u14.!(addr & ((1u << this.tag_bits) - 1));

        var lru_result = tag_store[index].access_update(tag_val);
        return lru_result;
    }

}